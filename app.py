import streamlit as st
from dynare_irf_utils import load, get_irf, plot_irf_df, convert, get_irf_endo_vars, dump_figure
from datetime import datetime
from matplotlib.figure import Figure
import os
import io


def remove_suptitle(fig: Figure) -> Figure:
    """
    Remove the suptitle from a matplotlib figure.

    Parameters:
        fig (matplotlib.figure.Figure): The figure object.

    Returns:
        matplotlib.figure.Figure: The modified figure object.
    """
    if fig._suptitle is not None:
        fig._suptitle.set_text(None)
        fig.tight_layout()
    return fig


st.set_page_config(
    page_title="IRF Plotter",
    page_icon="ðŸ“ˆ",
)
st.title("IRF Plotter for MAT Files")


st.markdown("""
This tool allows you to upload MATLAB `.mat` files containing `oo_` and `M_` data to visualize impulse response functions (IRFs). It helps in selecting variables and shocks for plotting and provides options to customize and download the plots.
""")

with st.expander("How to Use"):
    st.markdown("""
    ### Instructions:
    1. Upload a `.mat` file containing `oo_` and `M_` data.
    2. Ensure that `oo_` includes the impulse response functions (IRFs).
    3. Select endogenous variables and shocks to plot the IRFs.

    #### Example for saving in MATLAB:
    ```matlab
    dynare('example_model.mod')
    save('example_results', 'oo_', 'M_')
    ```

    #### Note on display names:
    If `long_name` is defined in the `.mod` file, it will be used as the display name for IRFs. For more details on `long_name`, refer to the [Dynare Manual - Variable Declarations](https://archives.dynare.org/manual/Variable-declarations.html).
    ```matlab
    var c $C$ (long_name='Consumption');
    ```
    """)

# Option to use a sample file
use_sample_file = st.checkbox("Try the demo with a sample MAT file")
if use_sample_file:
    # Add notes about the sample file
    with st.expander("About the sample.mat file"):
        st.markdown("""
        ### About the sample.mat File

        The `sample.mat` file is generated by running the following `.mod` file with Dynare 4.6.3:

        - **MOD File**: [Gali_2015_chapter_5_commitment.mod](https://github.com/JohannesPfeifer/DSGE_mod/blob/master/Gali_2015/Gali_2015_chapter_5_commitment.mod)
        - **Source Repository**: [Johannes Pfeifer's DSGE Mod Repository](https://github.com/JohannesPfeifer)

        This `.mod` file replicates the commitment case described in Chapter 5 of Gali (2015).

        #### How to Generate the File
        1. Clone the repository from [Johannes Pfeifer's GitHub](https://github.com/JohannesPfeifer).
        2. Navigate to the `Gali_2015` folder.
        3. Run the `.mod` file using Dynare 4.6.3 or later:
           ```bash
           dynare Gali_2015_chapter_5_commitment.mod
           ```
        4. Save the results as `sample.mat`
           ```matlab
           save('sample.mat', 'oo_', 'M_')
           ```

        #### Reference
        - Gali, J. (2015). *Monetary Policy, Inflation, and the Business Cycle: An Introduction to the New Keynesian Framework and Its Applications* (2nd ed.). Princeton University Press.
        """)

mat_file_path = None
uploaded_file = None

if not use_sample_file:
    uploaded_file = st.file_uploader("Upload a MAT file", type=["mat"], disabled=use_sample_file)

if use_sample_file:
    sample_file_path = "sample.mat"
    if os.path.exists(sample_file_path):
        mat_file_path = sample_file_path
    else:
        st.error("Sample MAT file (sample.mat) not found.")

elif uploaded_file is not None:
    mat_file_name = os.path.splitext(uploaded_file.name)[0]

    mat_file_path = uploaded_file

if mat_file_path is not None:
    if isinstance(mat_file_path, str):  # Path to the sample file
        data = load(mat_file_path)
    else:  # Uploaded file (BytesIO)
        data = load(mat_file_path)

    oo_ = data.get('oo_', None)
    M_ = data.get('M_', None)

    if oo_ is None:
        st.error("The uploaded MAT file does not contain 'oo_' data.")
    else:
        # Retrieve the list of endo_names_long
        endo_vars_shocks = get_irf_endo_vars(oo_, M_)
        endo_vars = endo_vars_shocks[list(endo_vars_shocks.keys())[0]]

        endo_names_long = sorted([convert(name, M_, vartype='endo', length='long') for name in endo_vars])

        # Allow the user to select endogenous variables
        selected_endo_names_long = st.multiselect(
            "Select endogenous variables to plot:",
            options=endo_names_long,
            default=endo_names_long[:5]  # Select the first 5 by default
        )

        if selected_endo_names_long:
            # Convert selected variables to short names
            selected_endo_names_short = [
                convert(long_name, M_, vartype='endo', length='short') for long_name in selected_endo_names_long
            ]

            # Retrieve IRF dataframes
            shock_dfs = get_irf(oo_, M_)

            # Retrieve the list of shocks
            shock_list = list(shock_dfs.keys())
            long_shock_list = [convert(shock, M_, vartype='exo', length='long') for shock in shock_list]

            # Allow the user to select shocks
            selected_shocks = st.selectbox(
                "Select shocks to plot:",
                options=long_shock_list,
                index=0  # Select the first one by default
            )

            # Plot options
            with st.expander("Plot Options"):
                n_col = st.number_input(
                    "Number of columns for the plot layout:",
                    min_value=1,
                    max_value=5,
                    value=2,  # Default value
                    step=1
                )
                plot_xlabel = st.text_input("X-axis label:", value="Time")
                plot_ylabel = st.text_input("Y-axis label:", value="Response")
                perods = st.number_input(
                    "Number of periods to plot:",
                    min_value=1,
                    max_value=100,
                    value=len(shock_dfs[shock_list[0]]),  # Default value
                    step=1
                )

            if selected_shocks:
                # Plot for each selected shock
                for long_shock_name in [selected_shocks, ]:
                    shock_name = convert(long_shock_name, M_, vartype='exo', length='short')
                    df = shock_dfs[shock_name]
                    st.subheader(f"Shock: {long_shock_name}")

                    # Plot
                    fig = plot_irf_df(
                        df[:perods],
                        selected_endo_names_short,
                        shock_name,
                        n_cols=n_col,
                        M_=M_,
                        xlabel=plot_xlabel,
                        ylabel=plot_ylabel,
                    )
                    st.pyplot(fig)

                    # Display the dataframe
                    with st.expander("Display IRF Data"):
                        st.write(df)

                    # Generate file name
                    if uploaded_file is not None:
                        mat_file_name = os.path.splitext(uploaded_file.name)[0]
                    else:
                        mat_file_name = "sample"
                    today_date = datetime.now().strftime("%Y-%m-%d")
                    base_file_name = f"{mat_file_name}_{long_shock_name}_{today_date}"

                    # Select file format and download immediately
                    include_title = st.checkbox("Include figure title in the exported file", value=True)
                    fig_for_save = fig if include_title else remove_suptitle(fig)
                    file_format = st.selectbox(
                        "Select file format to download:",
                        options=["png", "pdf", "eps", "svg", "pkl"],
                    )

                    if file_format == "pkl":
                        pkl_bytes = dump_figure(fig_for_save)
                        st.download_button(
                            label="Download as pkl",
                            data=pkl_bytes,
                            file_name=f"{base_file_name}.pkl",
                            mime="application/octet-stream"
                        )
                    else:
                        buffer = io.BytesIO()
                        fig_for_save.savefig(buffer, format=file_format)
                        buffer.seek(0)
                        mime_type = {
                            "png": "image/png",
                            "eps": "application/postscript",
                            "pdf": "application/pdf",
                            "svg": "image/svg+xml"  
                        }[file_format]
                        st.download_button(
                            label=f"Download as {file_format}",
                            data=buffer,
                            file_name=f"{base_file_name}.{file_format}",
                            mime=mime_type
                        )

                    if file_format == "pkl":
                        with st.expander("About the PKL File"):
                            # Information about the PKL file and usage example
                            st.markdown("""
                            ### About the PKL File
                            The PKL file contains the following information:

                            - **figure**: The Matplotlib `Figure` object.
                            - **matplotlib_version**: The version of Matplotlib used to create the figure.
                            - **pickle_protocol**: The Pickle protocol version used for serialization.

                            #### How to Load the PKL File

                            You can load the saved PKL file and reuse the figure in Python using the following code:

                            ```python
                            import pickle
                            import matplotlib.pyplot as plt

                            # Load the PKL file
                            with open('saved_figure.pkl', 'rb') as f:
                                data = pickle.load(f)

                            # Extract the figure object
                            fig = data['figure']

                            # Get all axes from the figure
                            axes = fig.get_axes()

                            # Modify all axes
                            for ax in axes:
                                for line in ax.get_lines():  # Iterate over all lines in the axis
                                    line.set_linestyle('--')  # Set the line style to dashed
                                    line.set_marker('o')     # Add circle markers

                            # Display the modified figure
                            plt.show(fig)
                            ```
                            """)
            else:
                st.warning("Please select at least one shock to plot.")
        else:
            st.warning("Please select at least one endogenous variable to plot.")


# Add a disclaimer section
st.markdown("""
---
### Disclaimer

This tool is provided "as is" without any guarantees of accuracy. The authors and contributors are not responsible for any errors, omissions, or outcomes resulting from the use of this tool. Use it at your own risk.
""")


# Add copyright notice to the footer
st.markdown("""
---
Â© 2025 [mitsuhir0](https://github.com/mitsuhir0). All rights reserved.
""")

